**什么是TCP？**

TCP协议是面向连接的、可靠的、基于字节流的传输层通信协议。

**什么是TCP连接？**

简单来说就是，⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接。

- Socket：由IP地址和端口号组成
- 序列号：用于解决乱序问题
- 窗口大小：用于流量控制

**我们可以通过四元组来唯一确定一个TCP连接：**

- 源地址
- 源端口
- 目的地址
- 目的端口

源地址和目的地址存于IP协议，用于寻找主机。

源端口和目的端口存于TCP头部，用于寻找进程。

​    ![0](data:,)

**序列号：**在建立连接时由发送端产生的随机数作为初始值，通过SYN包发送给接收端，每发送一次数据，就累加一次该数据字节数的大小。可以维护网络包的顺序。

**确认应答号：**指下一次期望收到的数据序列号，发送端收到这个应答号后可以认为在这个应答号之前的数据都已经被正常接收了。可以用来解决丢包问题。

**控制位：**

- ACK：置为1时，确认应答字段变为有效，TCP规定除了最初建立连接的SYN包以外，ACK都为1。
- RST：置为1时，表示TCP连接发生异常，必须强制断开连接。
- SYN：置为1时，表示发起连接请求，会以随机数初始化序列号。
- FIN：置为1时，表示发起之后都不会发送数据，请求断开连接。

​    ![0](data:,)

- 源端口号和目标端口号：标识发送给哪个进程
- 包长度：保存了UDP首部长度和数据长度之和
- 校验和：是为了提供可靠的UDP首部而设计的

**TCP和UDP的区别：**

|                    | TCP                                            | UDP                                              |
| ------------------ | ---------------------------------------------- | ------------------------------------------------ |
| 连接               | 面向连接的传输层协议，传输前需要建立连接       | 不需要连接，直接传数据                           |
| 服务对象           | 一对一                                         | 一对一、一对多、多对多                           |
| 可靠性             | 数据可以⽆差错、不丢失、不重复、按需到达       | 是尽最⼤努⼒交付，不保证可靠交付数据             |
| 拥塞控制、流量控制 | 俩大机制保证数据传输的安全性                   | 无                                               |
| 首部开销           | 首部字段较多，开销较大，选择选项字段还可以增长 | 固定8个字节                                      |
| 传输方式           | 字节流传输，无边界，保证有序可靠               | 以包为单位发送，是有边界的，但可能会丢包和乱序。 |

分片不同：

TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。

UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

​    ![0](data:,)

**三次握手：**

一开始，客户端和服务端都处于CLOSED状态。服务器先启动监听端口，进入LISTEN状态。

1. 客户端以随机数初始化序列号置于TCP首部的序号字段中，并将控制位SYN置为1表示是一个SYN报文，发送给服务端请求发起连接，不含数据。
2. 服务端收到SYN报文后，以随机数初始化服务端的序列号，填入TCP的首部的序号字段中，并在确认应答号字段填入客户端序号+1，然后将控制位的ACK和SYN置为1发送给客户端
3. 客户端收到之后，将发送一个TCP首部控制位ACK置为1的，并且在确认应答号字段填入服务端序号+1发送给服务端，之后客户端进入ESTABLISHED,服务端在收到客户端的ACK后进入，ESTABLISHED

**为什么要三次握手？二次握手可以吗？四次握手？**

**三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。**

1. **避免历史连接：**在网络拥堵情况下，旧的连接可能会比新的连接先到达服务端，那么当服务端返回旧链接的确认应答号时，在三次握手的情况下客户端能够根据上下文判断出这是一个旧的连接，就会在第三次发送RST报文给服务器中止这一次连接。
2. **同步双方的初始序列号：**俩次握手只能保证一方的初始序列号被对方成功接收，无法保证双方的初始序列号都能被确认接收
3. **避免资源浪费：**在网络阻塞情况下，客户端有可能没有收到来自服务端的ACK，就会重复发送SYN给服务端，而服务端由于没有第三次握手，所以就不知道客户端有没有收到自己的ACK，这时服务器重复接受⽆⽤的连接请求 SYN 报文，重复建立连接造成资源的浪费。

**第二次握手传回了ACK，为什么还要回传SYN？**

传回了ACK表示服务端接收到了客户端发送出的信号，回传SYN表示服务端可以正确的接收到客		 户端所发送的信息，这样才能够建立起可靠的通信信道

**四次挥手：**

断开一个TCP连接需要四次挥手

1- 主动关闭方 发送一个FIN给被动关闭方进入FIN_WAIT_1状态，表示自己之后不会传输数据了

2- 被动关闭方 接收FIN，返回一个ACK，服务端进入CLOSED_WAIT状态

3- 被动关闭方 在发送完自己的数据之后发送一个FIN给主动关闭方

4- 主动关闭方 收到FIN，回复一个ACK后进入TIME_WAIT状态

主动提出要关闭连接的一方需要等待被动关闭连接方发送完数据也确认关闭才能关闭一个TCP连接

只有主动关闭的一方才有TIME_WAIT状态

**为什么四次挥手？三次可以吗？**

- 关闭连接时，客户端向服务端发送FIN仅仅表示客户端不发送数据了，但还能接受数据
- 服务端收到FIN后先回一个CK给客户端，然后服务端需要处理发送完自己的数据，才会发送FIN给客户端表示关闭连接

**为什么TIME_WAIT等待的时间是2MSL?**

 ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包

被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。

**为什么要有TIME_WAIT状态？**

只有主动关闭的一方才有TIME_WAIT状态

- 防止具有相同的四元组的旧的数据包被接收
- 保证被动关闭连接的一方能被正确接收到来自主动关闭连接方最后的ACK报文，从而使被动关闭连接方能够正常的关闭

**TIME_WAIT过多的危害？**

- 内存资源占用
- 端口资源占用，如果发起连接一方的TIME_WAIT状态过多，占满了所有资源，会导致无法创建新的连接。

**SYN泛洪攻击，也就是SYN攻击（两次握手）？**

在三次握手阶段，服务器返回ACK后，客户端不进行向服务器发送ACK确认报文，这时服务器由于一直没有收到来自客户端的ACK，就会重复发送ACK给客户端。这样使得连接处于挂起的半连接状态，持续消耗服务器资源，长时间的由恶意程序持续发出半连接请求，就可能会导致服务器丧失服务功能。

**如何防范泛洪攻击？**

修改Linux内核参数，使用SYN Cookie，防火墙