**MyISAM和InnoDB的区别？**

- **行级锁**：MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁
- **事务**：MyISAM不支持，InnoDB支持并且提供事务的提交和回滚
- **外键**：MyISAM不支持，InnoDB支持
- **数据库异常崩溃后的安全恢复**：MyISAM不支持，InnoDB支持
- **MVCC**：MyISAM不支持，InnoDB支持

**表级锁和行级锁的对比：**

- 表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，消耗资源少，加锁快，不会出现死锁。但因为锁的粒度最大，触发锁冲突的概率最大，并发能力最弱。
- 行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。锁粒度小，并发能力强，但加锁的开销大，加锁慢，会出现死锁。

**InnoDB存储引擎的锁的算法：**

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包括记录本身

**数据库事务？**

要么全做，要么全都不做

**ACID?**

1. 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全都做，要么全都不做。
2. 一致性：执行事务前后，数据保持一致。例如在转账业务中，无论事务是否成功，转账人和收款人的总额不变。
3. 隔离性：并发访问数据库时，一个用户的事务不被其他事务干扰，各并发事务间数据库相对独立。
4. 持久性：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

**并发事务带来的问题？**

- **丢失修改：**一个事务的更新操作被另外一个事务的更新操作替换
- **脏读：**不同事务下，当前事务读到另外事务修改后还未提交的数据
- **不可重复读：**在一个事务内多次读取同一数据集合。在A事务还未结束前，B事务也访问了该同一数据集合并做了修改，由于B事务的修改，A事务的俩次读取数据可能不一致
- **幻读：**幻读本质上也属于不可重复读，A事务读取某个范围的数据，B事务在这个范围内插入新的数据，A再次读取这个范围的数据，此时俩次的读取结果不同

**不可重复读和幻读的区别**

不可重复读重点在于修改，幻读重点在于新增或者删除

**事务的隔离级别？**

1. 读取未提交RU：最低隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读、幻读
2. 读取已提交RC：允许读取并发事务已经提交的数据，可阻止脏读，但不可重复读、幻读仍有可能发生
3. 可重复读RR：对同一字段的多次读取结果都是一致的，除非数据被本身的事务修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
4. 可串行化S：最高隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间完全不可能产生干扰，可以防止脏读、不可重复读、幻读