**JDK1.7**

数组加链表也就是链表散列，使用拉链法解决hash冲突

**扰动函数：**指的是HashMap的hash方法。使用hash方法是为了减少碰撞。

**拉链法**：将链表和数组结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

**插入方式**：头插法，找到位置直接插入速度快，但在多线程环境下会成环。

```java
hash方法
​ static final int hash(Object key) {   
			int h;    
			return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); 
			} 
高16bit不变，低16bit和高16bit做异或 
```

**JDK1.8**

数组+链表+红黑树

需要满足俩个条件才会将链表转化为红黑树

- 链表长度大于阈值(默认为 8 )
- HashMap数组长度超过64 

**插入方式**：尾插法，红黑书也用不了头插法了，尾插法的性能也不差

**初始化：**

如果new HashMap() 不传值，默认大小是16，负载因子是0.75， 如果自己传入初始大小k，初始化大小为大于k的2的整数次方，例如如果传10，大小为16。

**解决hash冲突：**

当链表长度大于阈值8时，会先调用treeifyBin()方法。使用这个方法去判断数组长度是否大于或者等于64，是就转换为红黑书，否则只是执行resize()方法对数组扩容。如果链表长度不大于阈值就将值加入链表。

hash函数：先拿到key的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作。

**put()方法：**

​    ![0](data:,)

1. 判断数组是否为空，为空进行初始化;
2. 不为空，计算 k 的 hash 值，通过(n - 1) & hash计算应当存放在数组中的下标 index;
3. 查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；
4. 存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；
5. 如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；(如果当前节点是树型节点证明当前已经是红黑树了)
6. 如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树；
7. 插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍。

**为什么链表转红黑树阈值是8？为什么红黑树转链表是阈值是6？**

因为经过计算，在hash函数设计合理的情况下，发送hash碰撞8次的几率为百万分之6，已经非常低了。使用6转化回链表是因为如果hash碰撞次数如果在8徘徊，会一直发生链表和红黑树的互相转化，是为了预防发生这种情况。

**有序的Map？**

LinkedHashMap内部维护一个单链表，通过链表的前驱后继来维护插入或访问的顺序性。

TreeMap按照Key的自然顺序或Comprator的顺序进行排序，内部通过红黑树实现。

**线程安全？**

HashTable直接在方法上加synchronized关键字，锁住整个数组。

ConcurrentHashMap使用分段锁。

**分段锁的实现原理？**

ConcurrentHashMap成员变量使用volatile修饰，使用内存屏障免除指令的重排序，同时保证了内存的可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点

​                              