**.定义**

所谓的类加载机制就是，把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

**2.类的生命周期**

加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析统称为连接。

加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一 定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。

**3.触发类加载的条件**

1. 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则会先触发初始化。常见于new关键字，读取或设置一个类的静态字段或是调用一个类的静态方法。
2. 反射调用
3. 当初始化一个类的时候，如果它的父类还没有初始化先初始化父类
4. 虚拟机启动时，需要指定一个执行主类(包含main()方法的那个类)

**4.类加载的具体过程**

- 加载：在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
- 验证：验证作为连接中的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机本身的安全
- 准备：到了准备阶段才会正式为类变量分配内存空间并设置类变量的初始值。这些变量所使用的内存都将在方法区中分配。
- 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。
- 初始化：初始化是类加载过程中的最后一步。到了初始化阶段，才开始真正的执行类中定义的Java程序代码。初始化阶段也是执行类构造器()方法的过程，方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译 器可以不为这个类生成()方法。

**5.类加载器**

不同的类加载器负责加载不同的类，主要分为俩类：

- 启动类加载器（Bootstrap ClassLoader）：由C++语言实现，负责加载存在在\lib或-Xbootclasspath参数指定的路径中的类库加载到内存中，就是负责加载Java核心类

- 其他类加载器：

- - 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或是java.ext.dirs系统变量指定的路径中的所有类库，就是负责加载Java扩展的核心类之外的类
  - 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过 ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自 定义类加载器默认就是用这个加载器。

**6.双亲委派模型**

工作流程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给自己的父加载器去完成。每一层的类加载器都是这样，所以所有的加载请求最终都应该会被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围内没有找到对应的类的时候，子加载器才会自己去尝试加载这个类。

这样做的好处是不管是哪个加载器加载这个类，最终都会到顶层的启动类加载器进行加载，这样就可以保证使用不同的类加载器最终得到的都是同样一个Object对象。