**一、垃圾收集算法**

**1.标记-清除算法**

- 标记出所有需要回收的对象
- 标记完成后对所有被标记的对象进行统一的回收

不足：

- 标记和清除俩个过程的效率低
- 标记清除后会产生大量不连续的内存碎片，碎片过多就可能导致如果出现一个大的对象需要分配空间时，找不到足够的连续内存不得不提前进行另一次的垃圾回收

**2.复制算法**

将可用的内存一分为二，没次只使用其中一边。当其中一块的内存用完了，就将还存活着的对象复制到另外一块空内存内，然后再把已使用过的内存清理掉。这样每次都对一个半区进行内存的回收，内存分配的时候就不需要考虑内存碎片的情况

不足：

可以使用的内存大小变成了原来的一半

**3.标记整理算法**

复制收集算法在对象存活率高的时候，会进行频繁的复制操作，效率变低。所以根据老年代的特点，提出了标记整理算法

标记过程于标记-清除算法相同，但是清除阶段不是直接进行清除，而是将所有存活的对象都向一端移动，然后再清理掉边界外的可回收内存。

**4.分代收集算法**

将Java中的堆分为新生代和老年代，然后根据各自年代的特点选择合适的垃圾收集算法。

在新生代中，常常有大批的对象死去只有少量的存活，使用复制算法就比较合适

在老年代中，对象的存活率高、没有额外的空间对他进行分配担保，就需要采用标记-清除或标记整理算法进行回收

**二、JVM运行时内存**

​    ![0](data:,)

**1.JVM中的年代和Minor GC的过程**

HotSpot JVM把年轻代分为了三个部分：1个Eden区和2个Survivor区（分别就是From和To）。默认比例是8 ：1。

**Minor GC**：在GC开始的时候，对象只会存在Eden区和名为 “From” 的Survivor区，Survivor区的 “To” 区会是空的。紧接着进行GC，Eden区中所有存活的对象会被移动到To，而From中的仍然存活的对象会根据年龄值来确定他们的去向，当年龄值达到阈值就会被移动到老年代中，没有达到阈值的会被放到To区，经过这次GC以后Eden区和From区就被清空了。这个时候From和To就会交换角色，也就是复制算法，也就是新的“To”就是上 次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To 的Survivor区域是空的。Minor GC会一只重复这个过程直到To被填满，To如果被填满就会将所有的对象移动到老年代。

8：1的原因实际应用中是在新生代的内存使用达到90%时才会发生GC，所以预留10%的内存用于From区和To区进行垃圾收集和对调。

**2.Minor GC和Full GC的区别**

Minor GC：发生在年轻代的垃圾收集动作，发生频率非常频繁

Full GC/Major GC：发生在老年代的垃圾收集动作，出现了Major GC，经常会伴有至少一次的

Minor GC。Major GC速度一般会慢于Minor GC 10倍以上。

**3.空间分配担保机制**

在发生Minor GC之前，虚拟机会去检查老年代中的最大可用的连续空间是否大于年轻代所有对象的总空间，如果这个条件成立，那么Minor GC就可以确保是安全的。如果不成立，就需要查看HandlePrommotionFailure设置值是否允许担保失败。如果允许，那么就会继续检查老年代最大可利用的连续空间是否大于历次晋升到老年代中的对象的平均大小，如果大于就会尝试进行一次Minor GC。如果小于或是设置不允许担保失败，就会进行一次Full GC/Major GC。

**三、垃圾收集器**

​    ![0](data:,)

**1.Serial收集器** 

[ˈsɪəriəl]

复制算法。虚拟机运行在Client模式下的默认新生代收集器。最基本、发展历史最悠久的收集器。单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

优势：简单而高效（与其他单线程的收集器对比），对于限定单个CPU的环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集自然获得了最高的单线程效率。

​    ![0](data:,)

**2.ParNew收集器**

复制算法。ParNew收集器其实就是Serial收集器的多线程版本。

是许多运行在Server模式下的虚拟机中首选的新生代收集器，除了Serial收集器，目前只有它可以和CMS收集器配合工作。ParNew收集器默认开启的收集线程数与CPU数量相同。

​    ![0](data:,)

**3.Parallel Scavenge收集器**

[ˈpærəlel] [ˈskævɪndʒ]

复制算法。新生代收集器，并行的多线程收集器。

最大特点是：Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。

吞吐量=运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），吞吐量越高CPU利用率越高。

​    ![0](data:,)

**4.Serial Old收集器**

标记-整理算法。它是Serila收集器的老年代版本，同样是一个单线程收集器。Client模式使用

Server模式下，俩大用途：

- 与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure使用

**5.Parallel Old收集器**

标记-整理算法。多线程，Parallel Scavenge收集器的老年代版本。

在注重吞吐量及CPU资源敏感的场合，可以优先考虑使用Parallel Scavenge + Parallel Old收集器。

**6.CMS（Concurrent Mart Sweep）收集器**

是HotSpot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程和用户线程同事工作。关注点在于，尽可能的缩短垃圾收集时用户线程的停顿时间。

基于标记-清除算法

分为初始标记、并发标记、重新标记、并发清理四个阶段

初始标记和重新标记需要暂停其他的线程，初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快。并发标记就是进行垃圾收集的阶段。重新标记是为了修正并发标记期间用户程序继续运作而产生的变动的那一部分对象的标记几率，停顿时间大于初始标记小于并发标记。并发清理是耗时最长的阶段。

​    ![0](data:,)

缺点：

1. CMS收集器对CPU资源敏感。并发阶段会占用一部分线程导致应用程序变慢，总吞吐量下降
2. CMS无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败导致另一次Full GC。并发清理阶段，用户线程继续运行自然会产生新的垃圾，这部分垃圾出现在标记过程之后CMS自然无法清理，只好留待下一次GC。所以CMS不能等老年代几乎满了在进行收集，需要预留一部分提供并发程序运行时运作使用。如果预留空间不足就会发生“Concurrent Mode Failure”失败，虚拟机就会启动后备预案Serial Old。
3. 基于“标记-清除”算法，会出现大量的内存碎片

**7.G1收集器**

是当今收集器技术发展的最前沿成果之一。是一款面向服务端应用的垃圾收集器。

特点：

1.并行并发

能充分利用多CPU，多核环境下的硬件优势，缩短Stop-The-World停顿的时间，同 时可以通过并	 发的方式让Java程序继续执行 

2.分代收集

可以不需要其他收集器的配合管理整个堆，但是仍采用不同的方式去处理分代的对 象。 

3.空间整合

G1从整体上来看，采用基于“标记-整理”算法实现收集器

G1从局部上来看，采用基于“复制”算法实现。 

4.可预测停顿

使用G1收集器时，Java堆内存布局与其他收集器有很大差别，它将整个Java堆划 分成为多个大小相等的独立区域。	G1跟踪各个Region里面的垃圾堆积的价值大小 （回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列 表，每次根据允许的收集时间，优先回收价值最大的Region。