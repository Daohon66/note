**引用计数法**

在对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象就是不可能再被使用的。

难以解决循环引用问题

**可达性分析算法**

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明次对象是不可能再被使用的。

可以作为GC Root的对象有：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象

方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量 引用的对象；Native方法中引用的对象

在可达性性分析算法中，要真正宣告一个对象的死亡，至少需要俩次标记过程：

1. 如果对象在进行可达性分析的时候发现没有与GC Roots相连，会被第一次标记，并进行筛选，筛选这个对象是否有必要执行finalize()方法。当对象没有覆盖finalize()，或者finalize()方法已经被虚拟机调用过，这样的话对象就逃脱了
2. 如果这个对象被判定有必要执行finalize()方法，那么对象会被放入F-Queue队列，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。会对队列中的对象在进行一次标记，如果还是没有GC Roots相连，那么这个对象就真的会被回收了。

**JVM中的四种引用**

- 强引用：new出来的对象，即使会OOM垃圾收集器也不会清除
- 软引用：用来描述一些还有用但并非必须的对象。在系统发生OOM前，会将这些对象列进回收范围之中进行二次回收
- 弱引用：用户描述的非必须对象。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存怎么样，都会被回收。
- 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。