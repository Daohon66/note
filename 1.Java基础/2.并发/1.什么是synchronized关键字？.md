**1.什么是synchronized关键字？**

**synchronized** （悲观锁）是一个关键字解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。在操作同步资源前需要给同步资源在Java对象头里面加锁。

> Java对象头
>
> Hotspot虚拟机，对象头包含俩个部分：Mark Work（标记字段）、Klass Pointer（类型指针）
>
> Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化
>
> Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

**2.synchronized关键字的使用？**

1.修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

2.修饰静态方法：就是给类加锁，会作用于类的所有对象实例，进入同步代码块前要获得当前class的锁（静态成员属于类成员不管new多少次在内存中只有一份）。如果一个线程 A 调用一个实例对象的非静态 synchronized方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。

3.修饰代码块：指定需要加锁的对象，表示进入同步代码库前要获得给定对象的锁。

**3.synchronized关键字的原理？**

synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。

在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

**4.JDK1.6后对synchronized关键字底层做了哪些优化？**

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

**5.synchronized和ReentrantLock的区别**

**(1).俩者都是可重入锁**

“可重入锁”是指自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。

**(2).synchronized依赖于JVM而ReentrantLock依赖于API**

ReentrantLock是JDK层面是需要配合需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成

**(3).ReentrantLock比synchronized增加了一些高级功能**

- 等待可中断：在等待的线程可以放弃等待，改为处理别的事情lock.lockInterruptibly()
- 可实现公平锁：ReentrantLock可以指定是公平锁还是非公平锁，默认和sync一样是

非公平锁，ReentrantLock(boolean fair)

- 可实现选择性通知（锁可以绑定多个条件）：synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。

**6.synchronized锁升级**

为什么要锁升级？

互斥同步中对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成。

1. 无锁状态：Mark Word只是一个普通的对象，锁的标志位是01，是否偏向锁是0。无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

1. 偏向锁：偏向锁就是指一段同步代码一直被一个线程访问的情况下，会自动获取锁，降低获取锁的代价。具体过程就是，当一个线程访问同步代码块并获取锁的时候，线程在进入和退出的时候不再进行CAS操作来加锁或是解锁而是会根据Mark Word里存储的线程ID，如果和记录的ID相同就不需要去获取锁就可以直接执行。引入偏向锁的意义就是为了尽量减少不必要的轻量级锁执行，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要置换线程ID的时候依赖一次CAS原子指令就可以了
2. 轻量级锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。如果同步对象没有被锁定也就是锁的标志位为01状态，那么jvm首先会会在当前线程的虚拟机栈中建立一个名为锁记录的（Lock Record）空间，用于存储对象目前的Mark Word的拷贝。然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果成功了就代表该线程拥有了这个对象的锁，并且对象的锁标志位会置为00，表示进入轻量级锁状态。如果操作失败了，就意味着至少有一个线程在与当前线程竞争获取该对象的锁。虚拟机就会去检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁就可以直接进入同步块继续执行，否则的话就说明被其他的线程抢占了。俩条以上的线程竞争同一个锁的情况下，轻量级锁就会失效了，就会升级成重量级锁，锁的标志位置为10，此时Mark Word中存储的就是指向重量级锁的指针。若当前只有一个等待线程，则该线程会通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个线程来访时，就会升级成重量级锁
3. 重量级锁：锁标志位置为10。在这个状态下，未抢到锁的线程都会被阻塞。

